# Copyright 2022 Pixar
#
#    Licensed under the Apache License, Version 2.0 (the "Apache License")
#    with the following modification; you may not use this file except in
#    compliance with the Apache License and the following modification to it:
#    Section 6. Trademarks. is deleted and replaced with:
#
#    6. Trademarks. This License does not grant permission to use the trade
#       names, trademarks, service marks, or product names of the Licensor
#       and its affiliates, except as required to comply with Section 4(c) of
#       the License and to reproduce the content of the NOTICE file.
#
#    You may obtain a copy of the Apache License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the Apache License with the above modification is
#    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#    KIND, either express or implied. See the Apache License for the specific
#    language governing permissions and limitations under the Apache License.
#

# frozen_string_literal: true

module Windu

  module Mixins

    module SoftwareTitle

      # Methods to mix in to the SoftwareTitle class,
      # relating to ExtensionAttributes
      #
      # NOTE: Even though 'extensionAttributes' is plural, and
      # they come from the server in an Array, at the moment there
      # can only be one per SoftwareTitle.
      #
      module Requirements

        def self.included(includer)
          Windu.verbose_include includer, self
        end

        # Public Instance Methods
        ####################################

        # Add a requirement to this SoftwareTitle. These are
        # criteria used to determine if a computer has any
        # version of this title installed.
        #
        # When adding the requirement via this method, it is added
        # immediately to the server, there is no need to #save
        # the SoftwareTitle
        #
        # @param name [String] The name of the criterion
        #   To get an Array of all possible criteria names, use
        #   Windu::Requirement.available_names
        #
        # @param operator [String] The operator to use for
        #   comparing the value given here with the value for
        #   a computer.
        #   To get an Array of all operators available for some criterion,
        #   use Windu::Requirement.operators_for criterion_name
        #
        # @param value [String, integer] The value that will be
        #   compared with that on a computer, using the operator.
        #
        # @param type [String] how does Jamf Pro get this
        #   value for a computer? 'recon' means its a normal value
        #   gathered by a recon. 'extensionAttribute' means the value
        #   is generated by the extensionAttribute associated with
        #   this SoftwareTitle. Defaults to 'recon'.
        #
        # @param and_or [Symbol] :and or :or. Defines how this
        #   requirement is joined with the previous one in a chain of
        #   boolean logic. Default is :and
        #
        # @param order [Integer] The zero-based index of this
        #   requirement in the group. Determines the order of the chain
        #   of boolean logic with multiple requirements. To append
        #   the new requirement to the end, use nil, which is the default.
        #
        #
        # @return [Integer] The id of the new Requirement
        #
        def add_requirement(name:, operator:, value:, type: 'recon', and_or: :and)
          new_req = Windu::Requirement.create(
            name: name,
            operator: operator,
            value: value,
            type: type.to_s,
            and_or: and_or
          )

          req_id = new_req.save container_id: primary_id
          @lastModified = Time.now.utc
          @requirements << new_req

          req_id
        end

        # Update the details of an existing requirement
        #
        # You must provide either the Array index of the desired requirement
        # from the #requirements array, or a requirementId from one of them.
        #
        # For the other params, @see #add_requirement. If left nil, they are
        # not changed.
        #
        # @param index [Integer] The array index of the requirement in #requirements
        #   Must be provided if not providing requirementId.
        #
        # @param requirementId [Integer] The requirementId of the requirement in
        #   #requirements. Must be provided if not providing index.
        #
        # @return [Integer] The id of the updated Requirement
        #
        def update_requirement(index: nil, requirementId: nil, name: nil, operator: nil, value: nil, type: nil, and_or: nil)
          req = requirement_by_index_or_id(index: index, requirementId: requirementId)

          req.name = name if name
          req.operator = operator if operator
          req.value = value if value
          req.type = type.to_s if type
          req.and_or = and_or if and_or

          req.save
          @lastModified = Time.now.utc

          req.requirementId
        end

        # Delete a requirement by its index or its id
        #
        # @param index [Integer] The array index of the requirement in #requirements
        #   Must be provided if not providing requirementId.
        #
        # @param requirementId [Integer] The requirementId of the requirement in
        #   #requirements. Must be provided if not providing index.
        #
        # @return [Integer] The id of the deleted Extension Attribute
        #
        def delete_requirement(index: nil, requirementId: nil)
          return if @requirements.empty?

          req = requirement_by_index_or_id(index: index, requirementId: requirementId)
          @requirements.delete_if { |r| r == req }
          req.delete
        end

        # Private Instance Methods
        ##################################
        private

        def requirement_by_index_or_id(index: nil, requirementId: nil)
          if index
            req = @requirements[index]
          elsif requirementId
            req = @requirements.find { |r| r.requirementId == requirementId }
          else
            raise ArgumentError, 'Either index: or requirementId: must be provided to locate the desired requirement'
          end
          raise Windu::NoSuchItemError, "No requirement at index #{index}" unless req

          req
        end

      end # module ExtensionAttribute

    end # module SoftwareTitle

  end # module Mixins

end # module Windu
